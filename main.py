import numpy as np

class Connect4:
    def __init__(self, rows=6, cols=7):
        self.rows = rows
        self.cols = cols
        self.board = None
        self.scores = {1: 0, 2: 0}  # 1: human, 2: AI

    def initialize_board(self):
        self.board = np.zeros((self.rows, self.cols), dtype=int)


    def play(self, col, player):
        for row in range(self.rows - 1, -1, -1):
            if self.board[row][col] == 0:
                self.board[row][col] = player
                self.update_scores(player, row, col)
                return True
        return False

    def is_valid_move(self, col):
        #column is in the range of the board and column is not full
        return 0 <= col < self.cols and self.board[0][col] == 0

    def get_valid_moves(self):
        #returns a list of columns that are  available according to if the column is full or not
        #the function that checks for the condition is the is valid move function
        return [col for col in range(self.cols) if self.is_valid_move(col)]

    def get_children(self, player):
        children = []
        #generate the children the states are generated by inserting a disc for the human in each valid column
        for col in self.get_valid_moves():
            child_board = self.board.copy()

            # moves on rows from down to top and inserts the disc where the cell is empty  and then
            #  adds the child to the children and the corresponding column
            for row in range(self.rows - 1, -1, -1):
                if child_board[row][col] == 0:
                    child_board[row][col] = player
                    break
            children.append((child_board, col))
        return children

    def is_full(self):
        return np.all(self.board != 0)

    def update_scores(self, player, row, col):
        directions = [(0, 1), (1, 0), (1, 1), (1, -1)]
        for dr, dc in directions:
            count = 1
            for sign in [-1, 1]:
                r, c = row, col
                while 0 <= r + dr * sign < self.rows and 0 <= c + dc * sign < self.cols:
                    r, c = r + dr * sign, c + dc * sign
                    if self.board[r][c] == player:
                        count += 1
                        if count == 4:
                            self.scores[player] += 1
                            break
                    else:
                        break

    def print_board(self):
        print("\nCurrent Board:")
        print(self.board)
        print("\n")


def eval_state(board):
    #heuristic function
    # evaluats the states according to the number of connected fours 
    # TODO:find a better heuristic
    ai_score = count_connected_fours(board, 2)
    human_score = count_connected_fours(board, 1)
    return ai_score - human_score


def count_connected_fours(board, player):
    count = 0
    directions = [(0, 1), (1, 0), (1, 1), (1, -1)]
    rows, cols = board.shape

    for row in range(rows):
        for col in range(cols):
            if board[row][col] == player:
                for dr, dc in directions:
                    line = []
                    for i in range(4):
                        r, c = row + dr * i, col + dc * i
                        if 0 <= r < rows and 0 <= c < cols:
                            line.append(board[r][c])
                    if len(line) == 4 and all(cell == player for cell in line):
                        count += 1
    return count


def terminal_test(board):
    return np.all(board != 0)


def minimize(board, depth):
    #recursive calss till it reachses the depth , each call we decrease depth by 1
    if terminal_test(board) or depth == 0:
        return None, eval_state(board)
    min_child = None
    min_utility = float('inf')
    temp_game = Connect4()
    temp_game.board = board
    for child_board, col in temp_game.get_children(1):
        _, utility = maximize(child_board, depth - 1)
        if utility < min_utility:
            min_child = col
            min_utility = utility

    return min_child, min_utility


def maximize(board, depth):
    if terminal_test(board) or depth == 0:
        return None, eval_state(board)
    max_child = None
    max_utility = -float('inf')
    temp_game = Connect4()
    temp_game.board = board
    for child_board, col in temp_game.get_children(2):
        _, utility = minimize(child_board, depth - 1)
        if utility > max_utility:
            max_child = col
            max_utility = utility
    return max_child, max_utility


def decision(board, depth=4):
    #starts as a maximize state for the AI 
    col, _ = maximize(board, depth)
    return col


def play_game():
    game = Connect4()
    game.initialize_board()
    game.print_board()

    while not game.is_full():
        # Human Turn
        valid = False
        while not valid:
            try:
                col = int(input("Your turn! Choose a column (0-6): "))
                if game.is_valid_move(col):
                    valid = True
                    game.play(col, 1)
                else:
                    print("Invalid move! Try again.")
            except ValueError:
                print("Please enter a valid column number.")
        game.print_board()

        if game.is_full():
            break

        # AI Turn
        print("AI is thinking...")
        col = decision(game.board, depth=4)
        game.play(col, 2)
        print(f"AI chooses column {col}")
        game.print_board()

    # End game
    print("Game Over!")
    ai_score = game.scores[2]
    human_score = game.scores[1]
    print(f"Final Scores - AI: {ai_score}, Human: {human_score}")
    if ai_score > human_score:
        print("AI wins!")
    elif human_score > ai_score:
        print("You win!")
    else:
        print("It's a tie!")


if __name__ == "__main__":
    play_game()
